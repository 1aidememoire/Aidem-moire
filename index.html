<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Mots</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .error-row {
            color: #ef4444; /* red-500 */
            background-color: #fee2e2; /* red-100 */
        }
        .tab-button {
            @apply px-4 py-2 font-semibold;
        }
        .tab-button.active {
            @apply border-b-2 border-blue-500 text-blue-600;
        }
        .tab-button.inactive {
            @apply text-blue-500 hover:text-blue-700;
        }
        input:disabled, input[type="checkbox"]:disabled + label {
            @apply bg-gray-200 cursor-not-allowed text-gray-400;
        }
        .correct-answer {
            transition: all 0.2s ease-in-out;
        }
        .incorrect-answer {
             transition: all 0.2s ease-in-out;
        }
        .preserve-lines {
            white-space: pre-line;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div id="game-container" class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-4xl text-center flex flex-col items-center">

        <div id="custom-alert" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center">
            <div class="relative mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 id="alert-title" class="text-lg leading-6 font-medium text-gray-900"></h3>
                    <div class="mt-2 px-7 py-3">
                        <p id="alert-message" class="text-sm text-gray-500"></p>
                    </div>
                    <div class="items-center px-4 py-3">
                        <button id="alert-ok-button" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            OK
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="help-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4">
            <div class="relative mx-auto p-6 border w-full max-w-lg shadow-lg rounded-md bg-white">
                <div class="mt-3">
                    <h3 class="text-xl text-center leading-6 font-bold text-gray-900">Aide sur le fonctionnement du jeu</h3>
                    <div class="mt-4 px-2 py-3 text-left max-h-[60vh] overflow-y-auto">
                        <p class="text-sm text-gray-700">
                            Ce jeu a pour objectif de vous aider à mémoriser les informations que vous souhaitez connaître : capitale, nombre d'habitants par pays, vocabulaire, dates historiques, grammaire...
                        </p>
                        <p class="text-sm text-gray-700 mt-2">
                            Pour l'utiliser, vous devez avoir renseigné un classeur avec au moins 2 colonnes d'informations liées. Par exemple :
                        </p>
                        <div class="my-4 border rounded-lg overflow-hidden shadow-sm">
                            <table class="w-full text-sm text-left text-gray-500">
                                <thead class="text-xs text-gray-700 uppercase bg-gray-100">
                                    <tr>
                                        <th scope="col" class="px-4 py-2">Colonne A</th>
                                        <th scope="col" class="px-4 py-2">Colonne B</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="bg-white border-b"><td class="px-4 py-2 font-medium text-gray-900">France</td><td class="px-4 py-2">Paris</td></tr>
                                    <tr class="bg-white border-b"><td class="px-4 py-2 font-medium text-gray-900">Espagne</td><td class="px-4 py-2">Madrid</td></tr>
                                    <tr class="bg-white border-b"><td class="px-4 py-2 font-medium text-gray-900">Allemagne</td><td class="px-4 py-2">Berlin</td></tr>
                                    <tr class="bg-white border-b"><td class="px-4 py-2 font-medium text-gray-900">Irlande</td><td class="px-4 py-2">Dublin</td></tr>
                                    <tr class="bg-white"><td class="px-4 py-2 font-medium text-gray-900">Angleterre</td><td class="px-4 py-2">Londres</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="text-sm text-gray-700 mt-2">
                            Copiez ces informations et collez-les dans la case centrale. Ensuite, activez une des options et lancez le jeu.
                        </p>
                        
                        <ul class="list-disc list-inside text-sm text-gray-700 mt-2">
                            <li>Le <b>mode Saisie</b> vous demande de taper l'information recherchée.</li>
                            <li>Le <b>mode Choix multiples</b> vous présente 4 options et vous demande de cliquer sur la bonne réponse. Pour l'activer, il est nécessaire d'avoir collé au moins 8 cases d'un tableau.</li>
                            <li>Le <b>mode Flashcards</b> vous présente un mot avant de montrer l'information associée.</li>
                            <li>Le <b>mode Mixte</b>, qui nécessite au moins 20 cases d'un tableau, présente les mots selon les 3 modes ci-dessus, de façon aléatoire.</li>
                        </ul>

                        <p class="text-sm text-gray-700 mt-4">
                            Vous pouvez également utiliser le mode par défaut en ne cliquant sur aucune des options ci-dessus. Ce mode vous montre un mot et vous pouvez ensuite passer au suivant.
                        </p>

                        <p class="text-sm text-gray-700 mt-4">
                            Plusieurs options complémentaires sont également disponibles : 
                        </p>
                        <ul class="list-disc list-inside text-sm text-gray-700 mt-2">
                            <li><b>Tout revoir en aléatoire pendant X secondes</b> vous permet de fixer une durée de fin plutôt qu'un nombre de mots.</li>
                            <li><b>Lire dans l'ordre</b> vous permet de revoir les informations renseignées dans l'ordre dans lequel ils ont été renseignés.</li>
                            <li>Avec l'option <b>Timer</b>, les mots changent automatiquement et aléatoirement, sans intervention de l'utilisateur.</li>
                            <li><b>Afficher les autres données</b> permet d'afficher les informations renseignées dans les colonnes autres que Source et Cible.</li>
                            <li><b>Limiter le nombre de mots</b> permet, par exemple, de ne revoir que 10 mots sur les 1000 renseignés par exemple. Les 10 mots seront choisis aléatoirement.</li>
                        </ul>

                        <p class="text-sm text-gray-700 mt-4">
                            Vous pouvez copier jusqu'à 5 colonnes. Le jeu vous permet de déterminer avec lesquelles vous souhaitez travailler (colonne source = mot présenté ; colonne cible = mot recherché).
                        </p>

                        <p class="text-sm text-gray-700 mt-4">
                            Vous pouvez également importer des images. Le format JPEG est fortement recommandé. Le nom des images correspond aux informations de la 2e colonne. Par exemple, si vous ajoutez une photo de serpent intitulée "Reptile", en mode saisie, c'est le mot "Reptile" que vous devrez renseigner.
                        </p>

                    </div>
                    <div class="items-center px-4 py-3">
                        <button id="close-help-button" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            Retour
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="setup-screen" class="w-full">
            <h1 class="text-3xl font-bold mb-4 text-gray-800">Préparez le jeu</h1>
            <p id="help-link" class="text-blue-600 cursor-pointer hover:underline mb-6">Aide sur le fonctionnement du jeu</p>
            
            <div class="w-full mb-4">
                <div class="flex justify-around border-b">
                    <button id="text-tab-btn" class="tab-button active">Coller le texte</button>
                    <button id="image-tab-btn" class="tab-button inactive">Importer des images</button>
                </div>
                <div id="text-tab-content" class="pt-4">
                    <textarea id="word-input-all" class="w-full h-64 p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-300 text-gray-700 resize-none" placeholder="Collez ici vos mots (colonnes séparées par des tabulations, lignes par des sauts de ligne)."></textarea>
                </div>
                <div id="image-tab-content" class="hidden pt-4">
                    <input type="file" id="image-input" multiple accept="image/jpeg, image/png" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer">
                    <div id="image-preview-container" class="mt-4 grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4 max-h-64 overflow-y-auto p-2 border rounded-lg bg-gray-50"></div>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full mb-4">
                <div class="flex items-center space-x-2"><input type="checkbox" id="typing-mode-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="typing-mode-checkbox" class="text-gray-700">Mode Saisie</label></div>
                <div class="flex items-center space-x-2"><input type="checkbox" id="multiple-choice-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="multiple-choice-checkbox" class="text-gray-700" id="multiple-choice-label">Mode Choix multiples</label></div>
                <div class="flex items-center space-x-2"><input type="checkbox" id="flashcard-mode-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="flashcard-mode-checkbox" class="text-gray-700">Mode Flashcards</label></div>
                <div class="flex items-center space-x-2"><input type="checkbox" id="mixed-mode-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="mixed-mode-checkbox" class="text-gray-700" id="mixed-mode-label">Mode Mixte</label></div>
                <div class="flex items-center space-x-2 col-span-1 md:col-span-2"><input type="checkbox" id="review-all-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="review-all-checkbox" class="text-gray-700">Tout revoir en aléatoire pendant</label><input type="number" id="review-all-seconds" min="1" class="w-20 p-1 border border-gray-300 rounded-md" placeholder="ex: 60"><label for="review-all-seconds" class="text-gray-700">secondes</label></div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full mb-4">
                <div class="flex items-center space-x-2"><input type="checkbox" id="in-order-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="in-order-checkbox" class="text-gray-700">Lire dans l'ordre</label></div>
                <div class="flex items-center space-x-2"><input type="checkbox" id="show-other-cols-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="show-other-cols-checkbox" class="text-gray-700">Afficher les autres données</label></div>
                <div class="flex items-center space-x-2 col-span-1 md:col-span-2"><input type="checkbox" id="timer-mode-checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"><label for="timer-mode-checkbox" class="text-gray-700">Timer</label><input type="number" id="timer-seconds" min="0.1" max="99" step="0.1" class="w-20 p-1 border border-gray-300 rounded-md" placeholder="ex: 5"><label for="timer-seconds" class="text-gray-700">secondes</label></div>
            </div>


            <div class="flex flex-col md:flex-row gap-4 w-full mb-4 justify-center items-center">
                <div class="w-full md:w-1/2"><label for="source-column-select" class="block text-sm font-medium text-gray-700 mb-1 text-left">Colonne source</label><select id="source-column-select" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-300 text-gray-700"><option value="1">Colonne 1</option><option value="2">Colonne 2</option><option value="3">Colonne 3</option><option value="4">Colonne 4</option><option value="5">Colonne 5</option></select></div>
                <div class="w-full md:w-1/2"><label for="target-column-select" class="block text-sm font-medium text-gray-700 mb-1 text-left">Colonne cible</label><select id="target-column-select" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-300 text-gray-700"><option value="2">Colonne 2</option><option value="1">Colonne 1</option><option value="3">Colonne 3</option><option value="4">Colonne 4</option><option value="5">Colonne 5</option></select></div>
            </div>

            <div class="w-full mb-4 flex items-center justify-start gap-4"><label for="word-limit" class="text-gray-700">Limiter le nombre de mots (facultatif)</label><input type="number" id="word-limit" class="w-40 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-300 text-gray-700" placeholder="Par défaut : tous les mots"></div>
            
            <button id="start-button" class="mt-6 px-8 py-3 bg-blue-600 text-white font-semibold rounded-full shadow-lg hover:bg-blue-700 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Lancer le jeu</button>
        </div>

        <div id="game-screen" class="hidden w-full">
            <div class="flex justify-between items-center mb-6 w-full"><button id="return-button" class="px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-full shadow-sm hover:bg-red-600 transition duration-300">Retour au menu</button><div class="text-sm font-medium text-gray-500" id="progress-display"></div><div class="flex items-baseline gap-2"><h2 id="chronometer-label" class="text-sm font-medium text-gray-500">Chronomètre</h2><div id="timer-display" class="text-sm font-bold text-gray-900 tabular-nums">0.000s</div></div></div>
            <div id="word-display" class="min-h-[250px] flex flex-col items-center justify-center"><p class="text-5xl md:text-6xl lg:text-7xl font-bold text-gray-800 break-words max-w-full leading-tight">Mot</p></div>
            <div id="flashcard-reveal" class="invisible text-xl my-4 text-gray-600 italic min-h-[56px]"><span id="target-word-display" class="font-bold preserve-lines"></span><div id="other-cols-display" class="hidden text-sm mt-2 text-gray-500"></div></div>
            <div class="mt-2 w-full flex flex-col items-center"><div class="flex justify-center items-center gap-4"><button id="show-word-button" class="hidden mb-4 px-4 py-2 bg-green-600 text-white text-sm font-semibold rounded-full shadow-lg hover:bg-green-700 transition duration-300 transform hover:scale-105">Voir le mot</button><button id="next-word-button" class="mb-4 px-4 py-2 bg-blue-600 text-white text-sm font-semibold rounded-full shadow-lg hover:bg-blue-700 transition duration-300 transform hover:scale-105">Mot suivant →</button></div><input type="text" id="typing-input" class="hidden w-full max-w-md p-3 text-center border-2 border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200" placeholder="Tapez la réponse ici"><div id="multiple-choice-container" class="hidden grid grid-cols-1 sm:grid-cols-2 gap-4 w-full max-w-lg mt-4"></div><div id="game-instruction" class="text-gray-500 text-sm mt-4">Utilisez la flèche droite (→) pour passer au mot suivant.</div></div>
        </div>
        
        <div id="end-screen" class="hidden w-full">
            <h2 class="text-3xl font-bold mb-4 text-gray-800">Jeu terminé !</h2>
            <div id="review-all-summary" class="hidden text-lg mb-4"></div>
            <div class="mb-6"><span class="text-gray-600 text-lg">Votre temps total : </span><span id="final-time-display" class="text-4xl font-extrabold text-blue-600 tabular-nums">0.000s</span></div>
            <div id="history-container" class="mt-8 overflow-x-auto w-full"><h3 id="history-title" class="text-xl font-semibold mb-4 text-gray-800">Historique des mots et temps</h3><table class="min-w-full bg-white rounded-lg shadow"><thead class="bg-gray-200"><tr><th id="history-col-source" class="py-2 px-4 text-center font-medium text-gray-600">Source</th><th id="history-col-target" class="py-2 px-4 text-center font-medium text-gray-600">Cible</th><th class="py-2 px-4 text-center font-medium text-gray-600">Autres</th><th class="py-2 px-4 text-center font-medium text-gray-600">Temps</th></tr></thead><tbody id="history-table-body" class="divide-y divide-gray-200"></tbody></table></div>
            <div id="replay-options" class="flex items-center justify-center gap-2 mt-4"><label for="replay-longest-count">Revoir les</label><input type="number" id="replay-longest-count" min="1" class="w-20 p-1 border border-gray-300 rounded-md text-center" placeholder="10"><label for="replay-longest-count">mots les plus longs.</label></div>
            <div class="flex flex-col md:flex-row gap-4 mt-8"><button id="replay-button" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-full shadow-lg hover:bg-green-700 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">Rejouer</button><button id="reset-button" class="px-6 py-3 bg-gray-600 text-white font-semibold rounded-full shadow-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">Recommencer</button></div>
        </div>

    </div>

    <script>
        // DOM elements
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const endScreen = document.getElementById('end-screen');
        const wordInputAll = document.getElementById('word-input-all');
        const imageInput = document.getElementById('image-input');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const textTabBtn = document.getElementById('text-tab-btn');
        const imageTabBtn = document.getElementById('image-tab-btn');
        const textTabContent = document.getElementById('text-tab-content');
        const imageTabContent = document.getElementById('image-tab-content');
        const wordLimitInput = document.getElementById('word-limit');
        const startButton = document.getElementById('start-button');
        const timerDisplay = document.getElementById('timer-display');
        const wordDisplay = document.querySelector('#word-display p');
        const finalTimeDisplay = document.getElementById('final-time-display');
        const replayButton = document.getElementById('replay-button');
        const resetButton = document.getElementById('reset-button');
        const historyTableBody = document.getElementById('history-table-body');
        const customAlert = document.getElementById('custom-alert');
        const alertTitle = document.getElementById('alert-title');
        const alertMessage = document.getElementById('alert-message');
        const alertOkButton = document.getElementById('alert-ok-button');
        const returnButton = document.getElementById('return-button');
        const typingModeCheckbox = document.getElementById('typing-mode-checkbox');
        const multipleChoiceCheckbox = document.getElementById('multiple-choice-checkbox');
        const flashcardModeCheckbox = document.getElementById('flashcard-mode-checkbox');
        const mixedModeCheckbox = document.getElementById('mixed-mode-checkbox');
        const multipleChoiceLabel = document.getElementById('multiple-choice-label');
        const mixedModeLabel = document.getElementById('mixed-mode-label');
        const sourceColumnSelect = document.getElementById('source-column-select');
        const targetColumnSelect = document.getElementById('target-column-select');
        const progressDisplay = document.getElementById('progress-display');
        const typingInput = document.getElementById('typing-input');
        const flashcardReveal = document.getElementById('flashcard-reveal');
        const targetWordDisplay = document.getElementById('target-word-display');
        const multipleChoiceContainer = document.getElementById('multiple-choice-container');
        const gameInstruction = document.getElementById('game-instruction');
        const historyColSource = document.getElementById('history-col-source');
        const historyColTarget = document.getElementById('history-col-target');
        const nextWordButton = document.getElementById('next-word-button');
        const chronometerLabel = document.getElementById('chronometer-label');
        const showWordButton = document.getElementById('show-word-button');
        const inOrderCheckbox = document.getElementById('in-order-checkbox');
        const reviewAllCheckbox = document.getElementById('review-all-checkbox');
        const reviewAllSecondsInput = document.getElementById('review-all-seconds');
        const showOtherColsCheckbox = document.getElementById('show-other-cols-checkbox');
        const otherColsDisplay = document.getElementById('other-cols-display');
        const replayLongestCountInput = document.getElementById('replay-longest-count');
        const replayOptionsDiv = document.getElementById('replay-options');
        const historyTitle = document.getElementById('history-title');
        const helpLink = document.getElementById('help-link');
        const helpModal = document.getElementById('help-modal');
        const closeHelpButton = document.getElementById('close-help-button');
        const reviewAllSummary = document.getElementById('review-all-summary');
        const timerModeCheckbox = document.getElementById('timer-mode-checkbox');
        const timerSecondsInput = document.getElementById('timer-seconds');
        
        // Game state variables
        let wordData = [];
        let shuffledIndices = [];
        let currentWordIndex = 0;
        let gameStarted = false;
        let startTime = 0;
        let timerInterval = null;
        let masterTimer = null;
        let wordTimings = [];
        let wordStartTime = 0;
        let isTypingMode = false;
        let isMultipleChoiceMode = false;
        let isFlashcardMode = false;
        let isMixedMode = false;
        let isReviewAllMode = false;
        let isTimerMode = false;
        let wordTimerInterval = null;
        let audioCtx; // Pour le son
        let isWordRevealed = false;
        let isError = false;
        let sourceColumn;
        let targetColumn;
        const columnMap = { '1': 'Colonne 1', '2': 'Colonne 2', '3': 'Colonne 3', '4': 'Colonne 4', '5': 'Colonne 5' };

        // --- MODAL & ALERT FUNCTIONS ---
        function showCustomAlert(title, message) {
            alertTitle.textContent = title;
            alertMessage.textContent = message;
            customAlert.classList.remove('hidden');
        }
        alertOkButton.addEventListener('click', () => customAlert.classList.add('hidden'));
        helpLink.addEventListener('click', () => helpModal.classList.remove('hidden'));
        closeHelpButton.addEventListener('click', () => helpModal.classList.add('hidden'));

        // --- SETUP SCREEN LOGIC ---
        textTabBtn.addEventListener('click', () => switchTab('text'));
        imageTabBtn.addEventListener('click', () => switchTab('image'));

        function switchTab(tab) {
            if (tab === 'text') {
                textTabContent.classList.remove('hidden');
                imageTabContent.classList.add('hidden');
                textTabBtn.classList.add('active');
                textTabBtn.classList.remove('inactive');
                imageTabBtn.classList.add('inactive');
                imageTabBtn.classList.remove('active');
            } else {
                textTabContent.classList.add('hidden');
                imageTabContent.classList.remove('hidden');
                textTabBtn.classList.add('inactive');
                textTabBtn.classList.remove('active');
                imageTabBtn.classList.add('active');
                imageTabBtn.classList.remove('inactive');
            }
            checkMultipleChoiceAvailability();
        }

        imageInput.addEventListener('change', (e) => {
            imagePreviewContainer.innerHTML = '';
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const imgContainer = document.createElement('div');
                    imgContainer.className = 'relative p-1 border rounded-md shadow-sm bg-white';
                    const img = document.createElement('img');
                    img.src = event.target.result;
                    img.className = 'w-full h-20 object-cover rounded';
                    imgContainer.appendChild(img);
                    const name = document.createElement('p');
                    name.textContent = file.name.split('.').slice(0, -1).join('.');
                    name.className = 'text-xs truncate mt-1';
                    imgContainer.appendChild(name);
                    imagePreviewContainer.appendChild(imgContainer);
                };
                reader.readAsDataURL(file);
            });
            checkMultipleChoiceAvailability();
        });

        function checkMultipleChoiceAvailability() {
            let uniqueWords;
            let totalCount = 0;
            const isImageMode = !imageTabContent.classList.contains('hidden');

            if (isImageMode) {
                const imageFiles = imageInput.files;
                totalCount = imageFiles.length;
                uniqueWords = new Set(Array.from(imageFiles).map(file => file.name.split('.').slice(0, -1).join('.')));
            } else {
                const rawInput = wordInputAll.value.trim();
                const rows = rawInput.split('\n').filter(r => r.trim() !== '');
                totalCount = rows.length;
                const currentWordData = rows.map(row => row.split('\t')[targetColumnSelect.value - 1] || '').filter(Boolean);
                uniqueWords = new Set(currentWordData);
            }
            
            const isMCAvailable = uniqueWords.size >= 4;
            multipleChoiceCheckbox.disabled = !isMCAvailable;
            multipleChoiceLabel.classList.toggle('text-gray-400', !isMCAvailable);
            if (!isMCAvailable && multipleChoiceCheckbox.checked) {
                multipleChoiceCheckbox.checked = false;
            }

            const isMixedAvailable = totalCount >= 10;
            mixedModeCheckbox.disabled = !isMixedAvailable || !isMCAvailable; // MC must also be possible for the MC part of mixed mode
            mixedModeLabel.classList.toggle('text-gray-400', !isMixedAvailable || !isMCAvailable);
            if ((!isMixedAvailable || !isMCAvailable) && mixedModeCheckbox.checked) {
                mixedModeCheckbox.checked = false;
            }
        }
        wordInputAll.addEventListener('input', checkMultipleChoiceAvailability);
        targetColumnSelect.addEventListener('change', checkMultipleChoiceAvailability);

        // --- UTILITY FUNCTIONS ---
        function playBeep() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API is not supported in this browser.');
                    return;
                }
            }
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        function processImageFiles(files) {
            return Promise.all(Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageName = file.name.split('.').slice(0, -1).join('.');
                        resolve({ '1': e.target.result, '2': imageName, '3': '', '4': '', '5': '' });
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }));
        }

        function getRandomDistractors(correctAnswer, allAnswers) {
            const uniqueAnswers = [...new Set(allAnswers)];
            const distractors = new Set();
            const potentialDistractors = uniqueAnswers.filter(answer => answer !== correctAnswer);
            const shuffledDistractors = shuffle(potentialDistractors);
            for (let i = 0; i < Math.min(3, shuffledDistractors.length); i++) {
                distractors.add(shuffledDistractors[i]);
            }
            return Array.from(distractors);
        }

        function parseTsvWithNewlines(text) {
            const lines = text.trim().split(/\r\n|\n|\r/);
            const result = [];
            let currentLine = '';

            for (const line of lines) {
                currentLine += line;
                if ((currentLine.match(/"/g) || []).length % 2 === 0) {
                    const columns = currentLine.match(/("[\s\S]*?"|[^"\t]+)(?=\t|$)/g) || [];
                    const cleanedColumns = columns.map(cell => {
                        let cleaned = cell.trim();
                        if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                            cleaned = cleaned.substring(1, cleaned.length - 1);
                        }
                        return cleaned.replace(/""/g, '"');
                    });

                    result.push(cleanedColumns);
                    currentLine = '';
                } else {
                    currentLine += '\n';
                }
            }
            return result;
        }
        
        // --- GAME LIFECYCLE ---
        async function startGame(wordsToPlay) {
            if (timerModeCheckbox.checked && !audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API is not supported in this browser.');
                }
            }

            if (!wordsToPlay) {
                const isImageMode = !imageTabContent.classList.contains('hidden');
                if (isImageMode) {
                    const imageFiles = imageInput.files;
                    if (imageFiles.length === 0) {
                        showCustomAlert('Erreur', 'Veuillez sélectionner des images.');
                        return;
                    }
                    wordData = await processImageFiles(imageFiles);
                } else {
                    const rawInput = wordInputAll.value.trim();
                    if (rawInput === '') {
                        showCustomAlert('Erreur', 'Veuillez coller des mots.');
                        return;
                    }
                    const parsedRows = parseTsvWithNewlines(rawInput);
                    wordData = parsedRows.map(cols => {
                        return { '1': cols[0] || '', '2': cols[1] || '', '3': cols[2] || '', '4': cols[3] || '', '5': cols[4] || '' };
                    }).filter(item => Object.values(item).some(val => val.trim() !== ''));
                }

                const limit = parseInt(wordLimitInput.value);
                if (!isNaN(limit) && limit > 0 && limit < wordData.length) {
                    wordData = shuffle(wordData).slice(0, limit);
                }
                if (wordData.length === 0) {
                    showCustomAlert('Erreur', 'Aucun mot valide trouvé.');
                    return;
                }
            } else {
                wordData = wordsToPlay;
            }

            sourceColumn = sourceColumnSelect.value;
            targetColumn = targetColumnSelect.value;
            if (sourceColumn === targetColumn) {
                 showCustomAlert('Erreur', 'Les colonnes source et cible doivent être différentes.');
                 return;
            }
            
            isTypingMode = typingModeCheckbox.checked;
            isMultipleChoiceMode = multipleChoiceCheckbox.checked;
            isFlashcardMode = flashcardModeCheckbox.checked;
            isMixedMode = mixedModeCheckbox.checked;
            isReviewAllMode = reviewAllCheckbox.checked;
            isTimerMode = timerModeCheckbox.checked;

            if (isMixedMode) {
                const indices = Array.from({ length: wordData.length }, (_, i) => i);
                const shuffledAllIndices = shuffle(indices);
                
                const mcCount = Math.floor(wordData.length * 0.4);
                const flashcardCount = Math.floor(wordData.length * 0.3);
                const typingCount = wordData.length - mcCount - flashcardCount;

                const mcIndices = shuffledAllIndices.slice(0, mcCount).map(index => ({ index, mode: 'mc' }));
                const flashcardIndices = shuffledAllIndices.slice(mcCount, mcCount + flashcardCount).map(index => ({ index, mode: 'flashcard' }));
                const typingIndices = shuffledAllIndices.slice(mcCount + flashcardCount).map(index => ({ index, mode: 'typing' }));
                
                shuffledIndices = shuffle([...mcIndices, ...flashcardIndices, ...typingIndices]);
            } else {
                const indices = Array.from({ length: wordData.length }, (_, i) => i);
                shuffledIndices = inOrderCheckbox.checked && !isReviewAllMode && !isTimerMode ? indices : shuffle(indices);
            }
            
            setupScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            endScreen.classList.add('hidden');
            chronometerLabel.classList.add('hidden');
            
            typingInput.classList.add('hidden');
            multipleChoiceContainer.classList.add('hidden');
            flashcardReveal.classList.add('invisible');
            showWordButton.classList.add('hidden');
            nextWordButton.classList.remove('hidden');
            gameInstruction.classList.toggle('hidden', isMultipleChoiceMode || isMixedMode || isTimerMode);
            
            currentWordIndex = 0;
            wordTimings = [];
            gameStarted = true;
            startTime = performance.now();
            timerInterval = setInterval(updateTimer, 10);

            if (isReviewAllMode) {
                const duration = parseInt(reviewAllSecondsInput.value);
                if (isNaN(duration) || duration <= 0) {
                    showCustomAlert('Erreur', 'Veuillez entrer une durée valide.');
                    returnToSetup();
                    return;
                }
                masterTimer = setTimeout(endGame, duration * 1000);
            }

            if (isTimerMode) {
                const duration = parseFloat(timerSecondsInput.value);
                if (isNaN(duration) || duration <= 0) {
                    showCustomAlert('Erreur', 'Veuillez entrer une durée valide pour le timer.');
                    returnToSetup();
                    return;
                }
                wordTimerInterval = setInterval(() => {
                    playBeep();
                    nextWord();
                }, duration * 1000);
            }

            displayWord();
        }

        function updateTimer() {
            const elapsedTime = (performance.now() - startTime) / 1000;
            timerDisplay.textContent = elapsedTime.toFixed(3) + 's';
        }

        function displayWord() {
            if (gameStarted && (isReviewAllMode || isTimerMode) && currentWordIndex >= shuffledIndices.length) {
                shuffledIndices = shuffle(shuffledIndices);
                currentWordIndex = 0;
            }
            if (!gameStarted || currentWordIndex >= shuffledIndices.length) {
                if(gameStarted && (isReviewAllMode || isTimerMode)) { /* loop */ } else { return; }
            }
            
            isWordRevealed = false;
            isError = false;
            typingInput.classList.remove('border-red-500', 'bg-red-100', 'border-green-500', 'bg-green-100');
            typingInput.value = '';
            
            const currentMode = isMixedMode ? shuffledIndices[currentWordIndex].mode : null;
            const currentIndex = isMixedMode ? shuffledIndices[currentWordIndex].index : shuffledIndices[currentWordIndex];
            const sourceContent = wordData[currentIndex][sourceColumn];
            
            const displayElement = document.getElementById('word-display');
            if (sourceContent.startsWith('data:image')) {
                displayElement.innerHTML = `<img src="${sourceContent}" class="max-h-60 object-contain mx-auto rounded-lg shadow-md">`;
            } else {
                displayElement.innerHTML = `<p class="text-5xl md:text-6xl lg:text-7xl font-bold text-gray-800 break-words max-w-full leading-tight preserve-lines">${sourceContent}</p>`;
            }

            wordStartTime = performance.now();
            progressDisplay.textContent = `(${currentWordIndex + 1}/${wordData.length})`;
            flashcardReveal.classList.add('invisible');
            otherColsDisplay.classList.add('hidden');
            multipleChoiceContainer.innerHTML = '';
            
            typingInput.classList.add('hidden');
            multipleChoiceContainer.classList.add('hidden');
            showWordButton.classList.add('hidden');
            nextWordButton.classList.remove('hidden');

            document.removeEventListener('keydown', handleKeydown);
            document.removeEventListener('keydown', handleTyping);
            
            let activeMode;
            if (isMixedMode) {
                activeMode = currentMode;
            } else if (isTypingMode) {
                activeMode = 'typing';
            } else if (isMultipleChoiceMode) {
                activeMode = 'mc';
            } else if (isFlashcardMode) {
                activeMode = 'flashcard';
            } else { // Covers Default, ReviewAll and Timer mode
                activeMode = 'default';
            }

            switch (activeMode) {
                case 'typing':
                    typingInput.classList.remove('hidden');
                    nextWordButton.innerHTML = 'Valider';
                    typingInput.focus();
                    document.addEventListener('keydown', handleTyping);
                    break;
                case 'mc':
                    nextWordButton.classList.add('hidden');
                    multipleChoiceContainer.classList.remove('hidden');
                    displayMultipleChoice();
                    document.addEventListener('keydown', handleKeydown);
                    break;
                case 'flashcard':
                case 'default':
                    showWordButton.classList.remove('hidden');
                    nextWordButton.innerHTML = 'Mot suivant →';
                    document.addEventListener('keydown', handleKeydown);
                    break;
                default:
                    nextWordButton.innerHTML = 'Mot suivant →';
                    document.addEventListener('keydown', handleKeydown);
                    break;
            }
             if (isTimerMode) {
                showWordButton.classList.add('hidden');
                nextWordButton.classList.add('hidden');
            }
        }

        function displayMultipleChoice() {
            const currentIndex = isMixedMode ?
                shuffledIndices[currentWordIndex].index : shuffledIndices[currentWordIndex];
            const correctWord = wordData[currentIndex][targetColumn];
            const allPossibleAnswers = wordData.map(item => item[targetColumn]).filter(Boolean);
            const distractors = getRandomDistractors(correctWord, allPossibleAnswers);
            let answers = shuffle([correctWord, ...distractors]);
            multipleChoiceContainer.innerHTML = '';
            answers.forEach(answer => {
                const button = document.createElement('button');
                if (answer.startsWith('data:image')) {
                    button.innerHTML = `<img src="${answer}" class="h-24 w-full object-contain">`;
                    button.className = 'bg-gray-100 p-2 rounded-lg shadow-md hover:bg-gray-200 transition duration-150 flex items-center justify-center';
                } else {
                    button.textContent = answer;
                    button.className = 'bg-gray-200 text-gray-800 p-3 rounded-full font-semibold shadow-md hover:bg-gray-300 transition';
                }
                
                button.dataset.answer = answer;
                button.addEventListener('click', (e) => handleMultipleChoiceClick(e.currentTarget, answer === correctWord, correctWord));
                multipleChoiceContainer.appendChild(button);
            });
        }
        
        function handleMultipleChoiceClick(clickedButton, isCorrect, correctAnswer) {
            const timeForWord = performance.now() - wordStartTime;
            const currentIndex = isMixedMode ? shuffledIndices[currentWordIndex].index : shuffledIndices[currentWordIndex];
            
            // Disable all buttons
            const allButtons = multipleChoiceContainer.querySelectorAll('button');
            allButtons.forEach(btn => btn.disabled = true);

            if (isCorrect) {
                clickedButton.classList.remove('bg-gray-200', 'hover:bg-gray-300');
                clickedButton.classList.add('bg-green-500', 'text-white', 'correct-answer');
                wordTimings.push({ ...wordData[currentIndex], time: timeForWord, isError: false });
                setTimeout(nextWord, 800);
            } else {
                isError = true;
                clickedButton.classList.remove('bg-gray-200', 'hover:bg-gray-300');
                clickedButton.classList.add('bg-red-500', 'text-white', 'incorrect-answer');
                
                // Highlight the correct answer
                const correctButton = Array.from(allButtons).find(btn => btn.dataset.answer === correctAnswer);
                if(correctButton) {
                    correctButton.classList.remove('bg-gray-200', 'hover:bg-gray-300');
                    correctButton.classList.add('bg-green-500', 'text-white');
                } else { // Fallback if correct answer not on screen for some reason
                    revealWord();
                }

                wordTimings.push({ ...wordData[currentIndex], time: timeForWord, isError: true });
                nextWordButton.innerHTML = 'Mot suivant →';
                nextWordButton.classList.remove('hidden');
                document.addEventListener('keydown', handleKeydown);
            }
        }

        function checkTypedAnswer() {
            const currentMode = isMixedMode ?
                shuffledIndices[currentWordIndex].mode : null;
            if (!isTypingMode && currentMode !== 'typing') return;
            if (isError) {
                nextWord();
                return;
            }

            const typedWordRaw = typingInput.value.trim();
            if (typedWordRaw === '') {
                showCustomAlert('Attention', 'Veuillez entrer une réponse avant de continuer.');
                return;
            }
            const typedWord = typedWordRaw.toLowerCase();
            const currentIndex = isMixedMode ? shuffledIndices[currentWordIndex].index : shuffledIndices[currentWordIndex];
            const correctWord = wordData[currentIndex][targetColumn].trim().toLowerCase();
            if (typedWord === correctWord) {
                isError = false;
                typingInput.classList.add('border-green-500', 'bg-green-100', 'correct-answer');
                setTimeout(() => {
                     typingInput.classList.remove('border-green-500', 'bg-green-100');
                     nextWord();
                }, 800);
            } else {
                typingInput.classList.add('border-red-500', 'bg-red-100', 'incorrect-answer');
                revealWord();
                nextWordButton.innerHTML = 'Mot suivant →';
                isError = true;
                const timeForWord = performance.now() - wordStartTime;
                wordTimings.push({ ...wordData[currentIndex], time: timeForWord, isError: true });
            }
        }

        function revealWord() {
            const currentIndex = isMixedMode ?
                shuffledIndices[currentWordIndex].index : shuffledIndices[currentWordIndex];
            const currentWord = wordData[currentIndex];
            const targetContent = currentWord[targetColumn];
            
            if (targetContent.startsWith('data:image')) {
                targetWordDisplay.innerHTML = `<img src="${targetContent}" class="max-h-24 object-contain mx-auto rounded-lg">`;
            } else {
                targetWordDisplay.textContent = targetContent;
            }

            if (showOtherColsCheckbox.checked && !isMixedMode) {
                const otherColumns = Object.keys(currentWord).filter(key => key !== sourceColumn && key !== targetColumn && ['1', '2', '3', '4', '5'].includes(key) && currentWord[key]).map(key => currentWord[key]);
                if (otherColumns.length > 0) {
                    otherColsDisplay.innerHTML = otherColumns.join(' / ');
                    otherColsDisplay.classList.remove('hidden');
                }
            }
            flashcardReveal.classList.remove('invisible');
            isWordRevealed = true;
        }

        function nextWord() {
            const currentMode = isMixedMode ?
                shuffledIndices[currentWordIndex].mode : null;
            const currentIndex = isMixedMode ? shuffledIndices[currentWordIndex].index : shuffledIndices[currentWordIndex];

            // For non-interactive modes, record time here
            if (!isTypingMode && !isMultipleChoiceMode && !isMixedMode) {
                 const timeForWord = performance.now() - wordStartTime;
                 wordTimings.push({ ...wordData[currentIndex], time: timeForWord, isError: isError });
            } 
            // For flashcard in mixed mode
            else if (isMixedMode && currentMode === 'flashcard') {
                const timeForWord = performance.now() - wordStartTime;
                wordTimings.push({ ...wordData[currentIndex], time: timeForWord, isError: isError });
            }
            // For typing mode (mixed or not) on success
            else if ((isTypingMode || (isMixedMode && currentMode === 'typing')) && !isError) {
                const timeForWord = performance.now() - wordStartTime;
                wordTimings.push({ ...wordData[currentIndex], time: timeForWord, isError: false });
            }
            
            currentWordIndex++;
            if ((isReviewAllMode || isTimerMode)) {
                displayWord();
            } else if (currentWordIndex < shuffledIndices.length) {
                displayWord();
            } else {
                endGame();
            }
        }

        function endGame() {
            gameStarted = false;
            clearInterval(timerInterval);
            clearTimeout(masterTimer);
            clearInterval(wordTimerInterval);
            document.removeEventListener('keydown', handleKeydown);
            document.removeEventListener('keydown', handleTyping);

            gameScreen.classList.add('hidden');
            endScreen.classList.remove('hidden');
            finalTimeDisplay.textContent = ((performance.now() - startTime) / 1000).toFixed(3) + 's';
            
            replayButton.classList.add('hidden');
            replayOptionsDiv.classList.add('hidden');
            reviewAllSummary.classList.add('hidden');

            if (isMultipleChoiceMode || isMixedMode || isTypingMode) {
                const errorWords = wordTimings.filter(item => item.isError);
                if (errorWords.length > 0) {
                    historyTitle.textContent = "Mots avec erreur";
                    populateHistoryTable(errorWords);
                    replayButton.textContent = 'Rejouer les mots incorrects';
                    replayButton.classList.remove('hidden');
                } else {
                    wordTimings.sort((a, b) => b.time - a.time);
                    historyTitle.textContent = "Historique des mots et temps";
                    populateHistoryTable(wordTimings);
                    if (wordTimings.length > 0) {
                        replayButton.textContent = 'Rejouer les mots les plus longs';
                        replayButton.classList.remove('hidden');
                        replayOptionsDiv.classList.remove('hidden');
                    }
                }
            } else {
                 if ((isReviewAllMode || isTimerMode) && wordTimings.length > 0) {
                    const aggregatedTimes = new Map();
                    wordTimings.forEach(item => {
                        const key = item['1'] + '||' + item['2'];
                        if (!aggregatedTimes.has(key)) {
                            aggregatedTimes.set(key, { ...item, time: 0, count: 0 });
                        }
                        const entry = aggregatedTimes.get(key);
                        entry.time += item.time;
                        entry.count += 1;
                    });
                    wordTimings = Array.from(aggregatedTimes.values());
                    reviewAllSummary.textContent = `Nombre de mots vus : ${wordTimings.reduce((acc, item) => acc + item.count, 0)}`;
                    reviewAllSummary.classList.remove('hidden');
                }

                wordTimings.sort((a, b) => b.isError - a.isError || b.time - a.time);
                historyTitle.textContent = (isReviewAllMode || isTimerMode) ? "Mots affichés le plus longtemps" : "Historique des mots et temps";
                populateHistoryTable(wordTimings);
                const hasErrors = wordTimings.some(item => item.isError);
                const hasWords = wordTimings.length > 0;
                if (hasErrors) {
                    replayButton.textContent = 'Rejouer les mots incorrects';
                    replayButton.classList.remove('hidden');
                } else if (hasWords) {
                    replayButton.textContent = 'Rejouer les mots les plus longs';
                    replayButton.classList.remove('hidden');
                    replayOptionsDiv.classList.remove('hidden');
                }
            }
        }
        
        function populateHistoryTable(data) {
            historyTableBody.innerHTML = '';
            historyColSource.textContent = columnMap[sourceColumn];
            historyColTarget.textContent = columnMap[targetColumn];

            data.forEach(item => {
                const sourceContent = item[sourceColumn];
                const targetContent = item[targetColumn];
                const sourceCell = sourceContent.startsWith('data:image') ? `<td class="py-2 px-4 flex justify-center"><img src="${sourceContent}" class="h-12 w-12 object-cover rounded-md"></td>` : `<td class="py-2 px-4 whitespace-nowrap">${sourceContent}</td>`;
                const targetCell = 
                    targetContent.startsWith('data:image') ? `<td class="py-2 px-4 flex justify-center"><img src="${targetContent}" class="h-12 w-12 object-cover rounded-md"></td>` : `<td class="py-2 px-4 whitespace-nowrap">${targetContent}</td>`;
                
                const otherColumns = Object.keys(item).filter(key => key !== sourceColumn && key !== targetColumn && ['1', '2', '3', '4', '5'].includes(key) && item[key]).map(key => item[key]);
                const row = document.createElement('tr');
                if (item.isError) row.classList.add('error-row');
                row.className += ' hover:bg-gray-50 transition duration-150 text-center';
                row.innerHTML = `${sourceCell}${targetCell}<td class="py-2 px-4 whitespace-nowrap">${otherColumns.join(', ') || '-'}</td><td class="py-2 px-4 whitespace-nowrap">${(item.time / 1000).toFixed(3)}s</td>`;
                historyTableBody.appendChild(row);
            });
        }
        
        function returnToSetup() {
            if (gameStarted) {
                gameStarted = false;
                clearInterval(timerInterval);
                clearTimeout(masterTimer);
                clearInterval(wordTimerInterval);
                document.removeEventListener('keydown', handleKeydown);
                document.removeEventListener('keydown', handleTyping);
            }
            setupScreen.classList.remove('hidden');
            gameScreen.classList.add('hidden');
            endScreen.classList.add('hidden');
            chronometerLabel.classList.remove('hidden');
            timerDisplay.textContent = '0.000s';
            
            // Uncheck all checkboxes
            typingModeCheckbox.checked = false;
            multipleChoiceCheckbox.checked = false;
            flashcardModeCheckbox.checked = false;
            mixedModeCheckbox.checked = false;
            reviewAllCheckbox.checked = false;
            timerModeCheckbox.checked = false;
            inOrderCheckbox.checked = false;
            showOtherColsCheckbox.checked = false;
            
            // Call handleModeChange to reset the UI to a clean state
            handleModeChange();
        }

        /** MODIFIED FUNCTION **/
        function triggerNextAction() {
            if (!gameStarted || isTimerMode) return;

            const currentMode = isMixedMode ? shuffledIndices[currentWordIndex].mode : null;
            const isEffectiveMC = isMultipleChoiceMode || (isMixedMode && currentMode === 'mc');
            const isEffectiveTyping = isTypingMode || (isMixedMode && currentMode === 'typing');
            const isEffectiveFlashcard = isFlashcardMode || (isMixedMode && currentMode === 'flashcard');

            // Handle multiple choice actions
            if (isEffectiveMC) {
                if (isError) {
                    nextWord();
                }
                return;
            }

            // Handle typing actions
            if (isEffectiveTyping) {
                checkTypedAnswer();
                return;
            }
            
            // Handle classic flashcard behavior (reveal then next)
            if (isEffectiveFlashcard) {
                if (isWordRevealed) {
                    nextWord();
                } else {
                    revealWord();
                }
                return;
            }

            // For all other cases (Default mode, or Review All mode running by itself),
            // the "next" action is to simply move to the next word.
            // Revealing the word is handled exclusively by the "Voir le mot" button.
            nextWord();
        }

        function handleKeydown(event) {
            if (event.key === 'ArrowRight') triggerNextAction();
        }
        function handleTyping(event) {
            if (event.key === 'Enter') {
                checkTypedAnswer();
            }
        }
        
        function handleReplay() {
            let wordsToReplay = [];
            const hasErrors = wordTimings.some(word => word.isError);
            if (hasErrors) {
                wordsToReplay = wordTimings.filter(word => word.isError);
            } else {
                const count = parseInt(replayLongestCountInput.value) || 10;
                wordsToReplay = wordTimings.slice(0, count);
            }

            if (wordsToReplay.length === 0) {
                showCustomAlert('Information', 'Aucun mot à rejouer.');
                return;
            }
            const cleanWords = wordsToReplay.map(item => { const { time, isError, count, ...word } = item; return word; });
            startGame(cleanWords);
        }

        startButton.addEventListener('click', () => startGame());
        replayButton.addEventListener('click', handleReplay);
        resetButton.addEventListener('click', returnToSetup);
        returnButton.addEventListener('click', returnToSetup);
        nextWordButton.addEventListener('click', triggerNextAction);
        showWordButton.addEventListener('click', revealWord);
        
        const mainModes = [typingModeCheckbox, multipleChoiceCheckbox, flashcardModeCheckbox, mixedModeCheckbox];
        mainModes.forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    mainModes.forEach(other => { if (other !== e.target) other.checked = false; });
                }
                handleModeChange();
            });
        });

        reviewAllCheckbox.addEventListener('change', handleModeChange);
        timerModeCheckbox.addEventListener('change', handleModeChange);
        
        function handleModeChange() {
            // Get current state of all checkboxes
            const isTyping = typingModeCheckbox.checked;
            const isMC = multipleChoiceCheckbox.checked;
            const isFlash = flashcardModeCheckbox.checked;
            const isMixed = mixedModeCheckbox.checked;
            const isReview = reviewAllCheckbox.checked;
            const isTimer = timerModeCheckbox.checked;

            // --- Reset all disabled states to their base availability ---
            checkMultipleChoiceAvailability(); // This sets the baseline for MC and Mixed
            typingModeCheckbox.disabled = false;
            flashcardModeCheckbox.disabled = false;
            reviewAllCheckbox.disabled = false;
            timerModeCheckbox.disabled = false;
            // Keep its base disabled state for mixedModeCheckbox

            // --- Apply disabling rules based on the currently selected mode (by priority) ---
            if (isTimer) {
                // Timer is active -> disable incompatible modes.
                typingModeCheckbox.disabled = true;
                multipleChoiceCheckbox.disabled = true;
                flashcardModeCheckbox.disabled = true;
                mixedModeCheckbox.disabled = true;
            } else if (isReview) {
                // Review is active -> disable Saisie, MC, and Mixte.
                typingModeCheckbox.disabled = true;
                multipleChoiceCheckbox.disabled = true;
                mixedModeCheckbox.disabled = true;
            } else if (isMixed) {
                // Mixed is active -> disable other specific modes, plus Review and Timer
                typingModeCheckbox.disabled = true;
                multipleChoiceCheckbox.disabled = true;
                flashcardModeCheckbox.disabled = true;
                reviewAllCheckbox.disabled = true;
                timerModeCheckbox.disabled = true;
            } else if (isTyping || isMC || isFlash) {
                // Any other specific interactive mode is active -> disable Mixte, Review, and Timer
                mixedModeCheckbox.disabled = true;
                reviewAllCheckbox.disabled = true;
                timerModeCheckbox.disabled = true;
            }

            // --- Final state for associated inputs ---
            timerSecondsInput.disabled = !isTimer;
            reviewAllSecondsInput.disabled = !isReview;
        }
        
        window.addEventListener('load', () => {
            checkMultipleChoiceAvailability();
            handleModeChange();
        });
    </script>
</body>
</html>
